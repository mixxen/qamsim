<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>4-QAM Interactive Simulator</title>
<style>
body { background-color: #000; color: #fff; font-family: sans-serif; }
canvas { display: block; margin: 10px 0; border: 1px solid #444; }
input[type=text], input[type=number] { width: 50%; padding: 5px; font-size: 16px; color: #000; background-color: #fff; }
label { display: inline-block; margin-top: 8px; }
</style>
</head>
<body>
<h1>4-QAM Interactive Simulator</h1>
<p>Enter a binary sequence (multiple of 2 bits) to simulate the corresponding 4-QAM signal:</p>
<input type="text" id="bitSequence" value="00011011" />
<p>Carrier frequency f (relative to symbol rate):</p>
<input type="number" id="frequency" value="1" step="0.1" min="0" />
<p>Noise strength (AWGN, per-sample stdev):</p>
<input type="number" id="noiseStrength" value="0" step="0.05" min="0" max="10" />
<p id="snrDisplay">Estimated SNR: —</p>
<p id="powerDisplay">Power: Ps=—, Pn=—, SNR(linear)=—, SNR_th(linear)=—</p>

<canvas id="canvasIcos" width="400" height="120"></canvas>
<canvas id="canvasQsin" width="400" height="120"></canvas>
<canvas id="canvasCombined" width="400" height="120"></canvas>
<canvas id="canvasIcosMix" width="400" height="120"></canvas>
<canvas id="canvasQsinMix" width="400" height="120"></canvas>
<canvas id="canvasIext" width="400" height="120"></canvas>
<canvas id="canvasQext" width="400" height="120"></canvas>
<canvas id="canvasConstellation" width="400" height="400"></canvas>

<script>
(() => {
  const input = document.getElementById('bitSequence');
  const freqInput = document.getElementById('frequency');
  const noiseInput = document.getElementById('noiseStrength');
  const snrDisplay = document.getElementById('snrDisplay');
  const powerDisplay = document.getElementById('powerDisplay');

  // Canvas 2D contexts
  const ctxIcos = document.getElementById('canvasIcos').getContext('2d');
  const ctxQsin = document.getElementById('canvasQsin').getContext('2d');
  const ctxCombined = document.getElementById('canvasCombined').getContext('2d');
  const ctxIcosMix = document.getElementById('canvasIcosMix').getContext('2d');
  const ctxQsinMix = document.getElementById('canvasQsinMix').getContext('2d');
  const ctxIext = document.getElementById('canvasIext').getContext('2d');
  const ctxQext = document.getElementById('canvasQext').getContext('2d');
  const ctxConst = document.getElementById('canvasConstellation').getContext('2d');

  // Random normal generator (Box–Muller)
  function randn() {
    let u = 0, v = 0;
    while (u === 0) u = Math.random();
    while (v === 0) v = Math.random();
    return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
  }

  // Display parameters
  const pxPerSymbol = 100;
  const waveColor = 'cyan';
  const axisColor = 'white';
  const bitColor = { '00': 'lime', '01': 'red', '10': 'cyan', '11': 'magenta' };

  // keep a fixed number of samples per symbol ----
  const samplesPerSymbol = 400; // constant (prevents SNR from changing with f)

  function updateSimulation() {
    const bitStr = input.value.trim();
    if (bitStr.length % 2 !== 0 || !/^[01]+$/.test(bitStr)) {
      input.style.backgroundColor = '#f88';
      [ctxIcos, ctxQsin, ctxCombined, ctxIcosMix, ctxQsinMix, ctxIext, ctxQext, ctxConst].forEach(ctx => {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      });
      snrDisplay.textContent = 'Estimated SNR: — (invalid input)';
      powerDisplay.textContent = 'Power: Ps=—, Pn=—, SNR(linear)=—, SNR_th(linear)=—';
      return;
    }
    input.style.backgroundColor = '#fff';

    const N = bitStr.length / 2;

    // Carrier frequency (cycles per symbol)
    let f = parseFloat(freqInput.value);
    if (!Number.isFinite(f) || f < 0) {
      freqInput.style.backgroundColor = '#f88'; f = 1;
    } else {
      freqInput.style.backgroundColor = '#fff';
    }
    const twoPiF = 2 * Math.PI * f;

    // Noise per-sample stdev
    let ns = parseFloat(noiseInput.value);
    if (!Number.isFinite(ns) || ns < 0) { noiseInput.style.backgroundColor = '#f88'; ns = 0; }
    else { noiseInput.style.backgroundColor = '#fff'; }

    // Resize canvases
    const waveWidth = N * pxPerSymbol;
    [ctxIcos, ctxQsin, ctxCombined, ctxIcosMix, ctxQsinMix, ctxIext, ctxQext].forEach(ctx => ctx.canvas.width = waveWidth);
    ctxConst.canvas.width = Math.max(waveWidth, 300);
    ctxConst.canvas.height = ctxConst.canvas.width;

    // Symbol mapping: '0' -> -1, '1' -> +1
    const Ivals = [], Qvals = [];
    for (let i = 0; i < bitStr.length; i += 2) {
      Ivals.push(bitStr[i]   === '0' ? -1 : +1);
      Qvals.push(bitStr[i+1] === '0' ? -1 : +1);
    }

    // Buffers for plots
    const totalSamples = N * samplesPerSymbol;
    const IcosSamples = new Array(totalSamples);
    const QsinSamples = new Array(totalSamples);
    const combinedSamples = new Array(totalSamples);
    const IcosMixSamples = new Array(totalSamples);
    const QsinMixSamples = new Array(totalSamples);

    const Iest = new Array(N);
    const Qest = new Array(N);

    let k = 0;
    // We’ll also capture the basis Gram matrix for one symbol for the theory SNR
    let C_the = 0, S_the = 0, Z_the = 0, haveTheoryGram = false;

    for (let sym = 0; sym < N; sym++) {
      const I = Ivals[sym], Q = Qvals[sym];

      // LS sums for this symbol
      let C = 0, S = 0, Z = 0, X = 0, Y = 0;

      for (let n = 0; n < samplesPerSymbol; n++) {
        const t = sym + n / samplesPerSymbol;  // symbol time in [sym, sym+1)
        const c = Math.cos(twoPiF * t);
        const s = Math.sin(twoPiF * t);
        const noise = ns * randn();

        const Icos = I * c;
        const Qsin = Q * s;
        const combined = Icos + Qsin + noise;

        IcosSamples[k] = Icos;
        QsinSamples[k] = Qsin;
        combinedSamples[k] = combined;

        // Mixer products for plots
        const mixC = combined * c;
        const mixS = combined * s;
        IcosMixSamples[k] = mixC;
        QsinMixSamples[k] = mixS;

        // LS accumulators
        C += c * c;
        S += s * s;
        Z += s * c;
        X += combined * c;
        Y += combined * s;

        k++;
      }

      // least-squares solve for I and Q (works for any f) ----
      const det = C * S - Z * Z;
      if (det <= 1e-12) {
        Iest[sym] = 0; Qest[sym] = 0;  // degenerate (f too small); avoid blowup
      } else {
        Iest[sym] = (X * S - Y * Z) / det;
        Qest[sym] = (Y * C - X * Z) / det;
      }

      if (!haveTheoryGram) {
        C_the = C; S_the = S; Z_the = Z; haveTheoryGram = true;
      }
    }

    // --- measured SNR from symbol decisions ---
    // signal power per symbol (at decision): I^2 + Q^2 = 2 for 4-QAM mapping
    let sigPowSum = 0, noisePowSum = 0;
    for (let sym = 0; sym < N; sym++) {
      const sPow = Ivals[sym]*Ivals[sym] + Qvals[sym]*Qvals[sym]; // = 2
      const eI = Iest[sym] - Ivals[sym];
      const eQ = Qest[sym] - Qvals[sym];
      sigPowSum += sPow;
      noisePowSum += eI*eI + eQ*eQ;
    }
    const Ps = sigPowSum / N;
    const Pn = noisePowSum / N;
    const snrLinear = (Pn > 0) ? (Ps / Pn) : Infinity;
    const snrDb = Number.isFinite(snrLinear) ? (10 * Math.log10(snrLinear)) : Infinity;

    // --- theoretical SNR (decision stage), valid for any f with LS estimator ---
    // Var(Î)=σ²·S/Δ, Var(Q̂)=σ²·C/Δ  ⇒  Pn_th=σ²·(C+S)/Δ,  Ps=2  ⇒ SNR=2·Δ / (σ²·(C+S))
    const det_the = C_the * S_the - Z_the * Z_the;
    const snrThLinear = (ns > 0 && det_the > 1e-12)
      ? (2 * det_the) / (ns * ns * (C_the + S_the))
      : Infinity;
    const snrThDb = Number.isFinite(snrThLinear) ? (10 * Math.log10(snrThLinear)) : Infinity;

    snrDisplay.textContent = `Estimated SNR: ${Number.isFinite(snrDb) ? snrDb.toFixed(2) : '∞'} dB (theory: ${Number.isFinite(snrThDb) ? snrThDb.toFixed(2) : '∞'} dB)`;
    powerDisplay.textContent =
      `Power: Ps=${Ps.toFixed(3)}, Pn=${Pn.toFixed(3)}, ` +
      `SNR(linear)=${Number.isFinite(snrLinear) ? snrLinear.toFixed(2) : '∞'}, ` +
      `SNR_th(linear)=${Number.isFinite(snrThLinear) ? snrThLinear.toFixed(2) : '∞'}`;

    // ---------- plotting helpers ----------
    function drawWave(ctx, data, yMax, label) {
      const W = ctx.canvas.width, H = ctx.canvas.height;
      ctx.fillStyle = '#000'; ctx.fillRect(0, 0, W, H);
      const y0 = H / 2;
      ctx.strokeStyle = axisColor; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(0, y0); ctx.lineTo(W, y0); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, H); ctx.stroke();
      ctx.fillStyle = axisColor; ctx.font = '14px sans-serif'; ctx.fillText(label, 10, 15);

      ctx.strokeStyle = waveColor; ctx.lineWidth = 2;
      ctx.beginPath();
      const scaleY = (H / 2) / yMax;
      const ptsPerSym = samplesPerSymbol;
      let x = 0, y = y0 - data[0] * scaleY;
      ctx.moveTo(x, y);
      for (let i = 1; i < data.length; i++) {
        if (i % ptsPerSym === 0) { ctx.stroke(); ctx.beginPath(); }
        x = (i / data.length) * W; y = y0 - data[i] * scaleY;
        ctx.lineTo(x, y);
      }
      ctx.stroke();
    }

    function drawStepWave(ctx, values, yMax, label) {
      const W = ctx.canvas.width, H = ctx.canvas.height;
      ctx.fillStyle = '#000'; ctx.fillRect(0, 0, W, H);
      const y0 = H / 2;
      ctx.strokeStyle = axisColor; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(0, y0); ctx.lineTo(W, y0); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, H); ctx.stroke();
      ctx.fillStyle = axisColor; ctx.font = '14px sans-serif'; ctx.fillText(label, 10, 15);

      ctx.strokeStyle = waveColor; ctx.lineWidth = 2;
      ctx.beginPath();
      const scaleY = (H / 2) / yMax;
      ctx.moveTo(0, y0 - values[0] * scaleY);
      for (let sym = 0; sym < values.length; sym++) {
        const xEnd = ((sym + 1) / values.length) * W;
        const yVal = y0 - values[sym] * scaleY;
        ctx.lineTo(xEnd, yVal);
        if (sym < values.length - 1) {
          const yNext = y0 - values[sym+1] * scaleY;
          ctx.lineTo(xEnd, yNext);
        }
      }
      ctx.stroke();
    }

    // Draw modulation waveforms
    drawWave(ctxIcos,     IcosSamples,     1.2, 'I(t) * cos(2\u03C0f t)');
    drawWave(ctxQsin,     QsinSamples,     1.2, 'Q(t) * sin(2\u03C0f t)');
    drawWave(ctxCombined, combinedSamples, 1.5 + 3*ns, 'Icos + Qsin + noise');
    // Mixed (for illustration)
    drawWave(ctxIcosMix,  IcosMixSamples,  1.5 + 3*ns, '(I+Q+noise) * cos(2\u03C0f t)');
    drawWave(ctxQsinMix,  QsinMixSamples,  1.5 + 3*ns, '(I+Q+noise) * sin(2\u03C0f t)');

    // Estimated baseband
    const yMaxEst = 1.2 + 2 * ns;
    drawStepWave(ctxIext, Iest, yMaxEst, 'Estimated I(t)');
    drawStepWave(ctxQext, Qest, yMaxEst, 'Estimated Q(t)');

    // Constellation
    const Wc = ctxConst.canvas.width, Hc = ctxConst.canvas.height;
    ctxConst.fillStyle = '#000'; ctxConst.fillRect(0, 0, Wc, Hc);
    ctxConst.strokeStyle = axisColor; ctxConst.lineWidth = 1;
    ctxConst.beginPath(); ctxConst.moveTo(0, Hc/2); ctxConst.lineTo(Wc, Hc/2);
    ctxConst.moveTo(Wc/2, 0); ctxConst.lineTo(Wc/2, Hc); ctxConst.stroke();
    ctxConst.fillStyle = axisColor; ctxConst.font = '16px sans-serif';
    ctxConst.fillText('I', Wc - 15, Hc/2 - 5); ctxConst.fillText('Q', Wc/2 + 5, 15);
    ctxConst.font = '14px sans-serif'; ctxConst.fillText('Measured Constellation (Î,Q̂)', 10, 20);

    const margin = 25; let maxAbs = 1;
    for (let i = 0; i < N; i++) { maxAbs = Math.max(maxAbs, Math.abs(Iest[i]), Math.abs(Qest[i])); }
    const maxRadiusPx = Math.min(Wc, Hc) / 2 - margin;
    const unitToPx = maxRadiusPx / maxAbs;

    ctxConst.save();
    ctxConst.strokeStyle = '#444'; ctxConst.setLineDash([4,4]);
    ctxConst.beginPath();
    ctxConst.moveTo(Wc/2 - unitToPx, 0); ctxConst.lineTo(Wc/2 - unitToPx, Hc);
    ctxConst.moveTo(Wc/2 + unitToPx, 0); ctxConst.lineTo(Wc/2 + unitToPx, Hc);
    ctxConst.moveTo(0, Hc/2 - unitToPx); ctxConst.lineTo(Wc, Hc/2 - unitToPx);
    ctxConst.moveTo(0, Hc/2 + unitToPx); ctxConst.lineTo(Wc, Hc/2 + unitToPx);
    ctxConst.stroke(); ctxConst.restore();

    const r = 5;
    for (let sym = 0; sym < N; sym++) {
      const bits = bitStr[2*sym] + bitStr[2*sym+1];
      const x = Wc/2 + Iest[sym] * unitToPx;
      const y = Hc/2 - Qest[sym] * unitToPx;
      ctxConst.fillStyle = bitColor[bits] || 'white';
      ctxConst.beginPath(); ctxConst.arc(x, y, r, 0, 2*Math.PI); ctxConst.fill();
      ctxConst.fillStyle = axisColor;
      const dx = (Iest[sym] >= 0 ? 10 : -20), dy = (Qest[sym] >= 0 ? -10 : 20);
      ctxConst.fillText(bits, x + dx, y + dy);
    }
  }

  updateSimulation();
  input.addEventListener('input', updateSimulation);
  freqInput.addEventListener('input', updateSimulation);
  noiseInput.addEventListener('input', updateSimulation);
})();
</script>
</body>
</html>
