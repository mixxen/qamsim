<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>QAM Interactive Simulator</title>
<style>
body { background-color: #000; color: #fff; font-family: sans-serif; }
canvas { display: block; margin: 10px 0; border: 1px solid #444; }
input[type=text], input[type=number] { width: 50%; padding: 5px; font-size: 16px; color: #000; background-color: #fff; }
label { display: inline-block; margin-top: 8px; }
</style>
</head>
<body>
<h1>QAM Interactive Simulator</h1>
<p>Enter a binary sequence (multiple of log2(M) bits) to simulate the corresponding M-QAM signal:</p>
<input type="text" id="bitSequence" value="00011011" />
<p>Carrier frequency f (relative to symbol rate):</p>
<input type="number" id="frequency" value="1" step="0.1" min="0" />
<p>Noise strength (AWGN, per-sample stdev):</p>
<input type="number" id="noiseStrength" value="0" step="0.05" min="0" max="100" />
<p>Power normalization:</p>
<label><input type="checkbox" id="normalizePower" checked /> Normalize average symbol energy (Es=1)</label>
<div id="normInfo" style="color:#ccc; margin-top:4px;">Es used: — (scale=—, unnorm Es=—)</div>
<p>Modulation order M:</p>
<select id="modOrder">
  <option value="4" selected>4-QAM (QPSK)</option>
  <option value="16">16-QAM</option>
  <option value="64">64-QAM</option>
  <option value="256">256-QAM</option>
  <option value="1024">1024-QAM</option>
</select>
<p id="snrDisplay">Estimated SNR: —</p>
<p id="powerDisplay">Power: Ps=—, Pn=—, SNR(linear)=—, SNR_th(linear)=—</p>

<canvas id="canvasIcos" width="400" height="120"></canvas>
<canvas id="canvasQsin" width="400" height="120"></canvas>
<canvas id="canvasCombined" width="400" height="120"></canvas>
<canvas id="canvasIcosMix" width="400" height="120"></canvas>
<canvas id="canvasQsinMix" width="400" height="120"></canvas>
<canvas id="canvasIext" width="400" height="120"></canvas>
<canvas id="canvasQext" width="400" height="120"></canvas>
<canvas id="canvasConstellation" width="400" height="400"></canvas>

<script>
(() => {
  const input = document.getElementById('bitSequence');
  const freqInput = document.getElementById('frequency');
  const noiseInput = document.getElementById('noiseStrength');
  const normCheckbox = document.getElementById('normalizePower');
  const normInfo = document.getElementById('normInfo');
  const modOrderSelect = document.getElementById('modOrder');
  const snrDisplay = document.getElementById('snrDisplay');
  const powerDisplay = document.getElementById('powerDisplay');

  // Canvas 2D contexts
  const ctxIcos = document.getElementById('canvasIcos').getContext('2d');
  const ctxQsin = document.getElementById('canvasQsin').getContext('2d');
  const ctxCombined = document.getElementById('canvasCombined').getContext('2d');
  const ctxIcosMix = document.getElementById('canvasIcosMix').getContext('2d');
  const ctxQsinMix = document.getElementById('canvasQsinMix').getContext('2d');
  const ctxIext = document.getElementById('canvasIext').getContext('2d');
  const ctxQext = document.getElementById('canvasQext').getContext('2d');
  const ctxConst = document.getElementById('canvasConstellation').getContext('2d');
  // Preserve initial constellation canvas size (keep static)
  const CONST_W0 = ctxConst.canvas.width;
  const CONST_H0 = ctxConst.canvas.height;

  // Random normal generator (Box–Muller)
  function randn() {
    let u = 0, v = 0;
    while (u === 0) u = Math.random();
    while (v === 0) v = Math.random();
    return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
  }

  // Display parameters
  const pxPerSymbol = 100;
  const waveColor = 'cyan';
  const axisColor = 'white';
  const bitColor = { '00': 'lime', '01': 'red', '10': 'cyan', '11': 'magenta' };
  function colorForBits(bits) {
    if (bits.length === 2 && bitColor[bits]) return bitColor[bits];
    // Hash bits to a hue for variety
    let h = 0;
    for (let i = 0; i < bits.length; i++) h = (h * 31 + (bits.charCodeAt(i) & 255)) >>> 0;
    const hue = h % 360;
    return `hsl(${hue}, 80%, 60%)`;
  }

  // --- helpers: Gray-coded PAM mapping for square M-QAM ---
  function bitsToInt(bitStr) {
    let v = 0; for (let i = 0; i < bitStr.length; i++) v = (v << 1) | (bitStr[i] === '1' ? 1 : 0); return v;
  }
  function grayToBinary(g) {
    let b = 0; for (; g; g >>= 1) b ^= g; return b;
  }
  function pamFromGrayBits(bits) {
    const L = 1 << bits.length; // levels per axis
    const g = bitsToInt(bits);
    const idx = grayToBinary(g);
    return -(L - 1) + 2 * idx; // levels: -L+1, -L+3, ..., +L-1
  }

  // keep a fixed number of samples per symbol ----
  const samplesPerSymbol = 400; // constant (prevents SNR from changing with f)

  function updateSimulation() {
    const bitStr = input.value.trim();
    const M = parseInt(modOrderSelect.value, 10) || 4;
    const m = Math.log2(M) | 0;        // bits per symbol
    const kAxis = m / 2 | 0;           // bits per axis (square QAM)
    if (m % 2 !== 0) {
      // guard: only square M supported; fallback to 4-QAM
      modOrderSelect.value = '4';
      return updateSimulation();
    }
    // Compute normalization state and show theoretical Es used
    const EsAvgUnnormalized = 2 * (M - 1) / 3; // average Es for unnormalized square M-QAM
    const scale = (normCheckbox && normCheckbox.checked)
      ? (1 / Math.sqrt(Math.max(EsAvgUnnormalized, 1e-12)))
      : 1;
    const EsUsed = EsAvgUnnormalized * scale * scale;
    if (normInfo) {
      normInfo.textContent = `Es used: ${EsUsed.toFixed(3)} (scale=${scale.toFixed(3)}, unnorm Es=${EsAvgUnnormalized.toFixed(3)})`;
    }
    if (bitStr.length === 0 || bitStr.length % m !== 0 || !/^[01]+$/.test(bitStr)) {
      input.style.backgroundColor = '#f88';
      [ctxIcos, ctxQsin, ctxCombined, ctxIcosMix, ctxQsinMix, ctxIext, ctxQext, ctxConst].forEach(ctx => {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      });
      snrDisplay.textContent = 'Estimated SNR: — (invalid input)';
      powerDisplay.textContent = 'Power: Ps=—, Pn=—, SNR(linear)=—, SNR_th(linear)=—';
      return;
    }
    input.style.backgroundColor = '#fff';

    const N = bitStr.length / m;

    // Carrier frequency (cycles per symbol)
    let f = parseFloat(freqInput.value);
    if (!Number.isFinite(f) || f < 0) {
      freqInput.style.backgroundColor = '#f88'; f = 1;
    } else {
      freqInput.style.backgroundColor = '#fff';
    }
    const twoPiF = 2 * Math.PI * f;

    // Noise per-sample stdev
    let ns = parseFloat(noiseInput.value);
    if (!Number.isFinite(ns) || ns < 0) { noiseInput.style.backgroundColor = '#f88'; ns = 0; }
    else { noiseInput.style.backgroundColor = '#fff'; }

    // Resize canvases
    const waveWidth = N * pxPerSymbol;
    [ctxIcos, ctxQsin, ctxCombined, ctxIcosMix, ctxQsinMix, ctxIext, ctxQext].forEach(ctx => ctx.canvas.width = waveWidth);
    // Keep constellation size static regardless of waveform length
    ctxConst.canvas.width = CONST_W0;
    ctxConst.canvas.height = CONST_H0;

    // Map symbols (Gray-coded per-axis PAM), apply optional scaling
    const Ivals = new Array(N), Qvals = new Array(N), symBitsArr = new Array(N);
    for (let s = 0; s < N; s++) {
      const start = s * m;
      const symBits = bitStr.slice(start, start + m);
      const iBits = symBits.slice(0, kAxis);
      const qBits = symBits.slice(kAxis);
      Ivals[s] = pamFromGrayBits(iBits) * scale;
      Qvals[s] = pamFromGrayBits(qBits) * scale;
      symBitsArr[s] = symBits;
    }

    // Buffers for plots
    const totalSamples = N * samplesPerSymbol;
    const IcosSamples = new Array(totalSamples);
    const QsinSamples = new Array(totalSamples);
    const combinedSamples = new Array(totalSamples);
    const IcosMixSamples = new Array(totalSamples);
    const QsinMixSamples = new Array(totalSamples);

    const Iest = new Array(N);
    const Qest = new Array(N);

    let k = 0;
    // Accumulate Gram matrix terms across symbols for theory SNR
    let Cacc = 0, Sacc = 0, Zacc = 0;

    for (let sym = 0; sym < N; sym++) {
      const I = Ivals[sym], Q = Qvals[sym];

      // LS sums for this symbol
      let C = 0, S = 0, Z = 0, X = 0, Y = 0;

      for (let n = 0; n < samplesPerSymbol; n++) {
        const t = sym + n / samplesPerSymbol;  // symbol time in [sym, sym+1)
        const c = Math.cos(twoPiF * t);
        const s = Math.sin(twoPiF * t);
        const noise = ns * randn();

        const Icos = I * c;
        const Qsin = Q * s;
        const combined = Icos + Qsin + noise;

        IcosSamples[k] = Icos;
        QsinSamples[k] = Qsin;
        combinedSamples[k] = combined;

        // Mixer products for plots
        const mixC = combined * c;
        const mixS = combined * s;
        IcosMixSamples[k] = mixC;
        QsinMixSamples[k] = mixS;

        // LS accumulators
        C += c * c;
        S += s * s;
        Z += s * c;
        X += combined * c;
        Y += combined * s;

        k++;
      }

      // least-squares solve for I and Q (works for any f) ----
      const det = C * S - Z * Z;
      if (det <= 1e-12) {
        Iest[sym] = 0; Qest[sym] = 0;  // degenerate (f too small); avoid blowup
      } else {
        Iest[sym] = (X * S - Y * Z) / det;
        Qest[sym] = (Y * C - X * Z) / det;
      }

      Cacc += C; Sacc += S; Zacc += Z;
    }

    // --- measured SNR from symbol decisions ---
    // signal power per symbol (at decision): I^2 + Q^2
    let sigPowSum = 0, noisePowSum = 0;
    for (let sym = 0; sym < N; sym++) {
      const sPow = Ivals[sym]*Ivals[sym] + Qvals[sym]*Qvals[sym];
      const eI = Iest[sym] - Ivals[sym];
      const eQ = Qest[sym] - Qvals[sym];
      sigPowSum += sPow;
      noisePowSum += eI*eI + eQ*eQ;
    }
    const Ps = sigPowSum / N;
    const Pn = noisePowSum / N;
    const snrLinear = (Pn > 0) ? (Ps / Pn) : Infinity;
    const snrDb = Number.isFinite(snrLinear) ? (10 * Math.log10(snrLinear)) : Infinity;
    // Update norm info with measured sequence power
    if (normInfo) {
      normInfo.textContent = `Es used: ${EsUsed.toFixed(3)} (scale=${scale.toFixed(3)}, unnorm Es=${EsAvgUnnormalized.toFixed(3)}), Ps(seq)=${Ps.toFixed(3)}`;
    }
    // Es/N0 estimates (order-invariant when normalized)
    const esn0_est = (Pn > 0) ? (EsUsed / Pn) : Infinity;
    const ebn0_est = esn0_est / m;

    // --- theoretical SNR (decision stage), valid for any f with LS estimator ---
    // Var(Î)=σ²·S/Δ, Var(Q̂)=σ²·C/Δ  ⇒  Pn_th=σ²·(C+S)/Δ; Ps = average(I^2+Q^2)
    const C_the = Cacc / N, S_the = Sacc / N, Z_the = Zacc / N;
    const det_the = C_the * S_the - Z_the * Z_the;
    // Use EsUsed (target average Es) instead of sequence Ps
    const snrThLinear = (ns > 0 && det_the > 1e-12)
      ? (EsUsed * det_the) / (ns * ns * (C_the + S_the))
      : Infinity;
    const snrThDb = Number.isFinite(snrThLinear) ? (10 * Math.log10(snrThLinear)) : Infinity;
    const esn0_th = snrThLinear;
    const ebn0_th = esn0_th / m;

    snrDisplay.textContent = `Estimated SNR: ${Number.isFinite(snrDb) ? snrDb.toFixed(2) : '∞'} dB (theory: ${Number.isFinite(snrThDb) ? snrThDb.toFixed(2) : '∞'} dB)`;
    powerDisplay.textContent =
      `Power: Ps=${Ps.toFixed(3)}, Pn=${Pn.toFixed(3)}, ` +
      `SNR(linear)=${Number.isFinite(snrLinear) ? snrLinear.toFixed(2) : '∞'}, ` +
      `SNR_th(linear)=${Number.isFinite(snrThLinear) ? snrThLinear.toFixed(2) : '∞'}, ` +
      `Es/N0_est=${Number.isFinite(esn0_est) ? esn0_est.toFixed(2) : '∞'}, ` +
      `Es/N0_th=${Number.isFinite(esn0_th) ? esn0_th.toFixed(2) : '∞'}, ` +
      `Eb/N0_est=${Number.isFinite(ebn0_est) ? ebn0_est.toFixed(2) : '∞'}, ` +
      `Eb/N0_th=${Number.isFinite(ebn0_th) ? ebn0_th.toFixed(2) : '∞'}`;

    // ---------- plotting helpers ----------
    function drawWave(ctx, data, yMax, label) {
      const W = ctx.canvas.width, H = ctx.canvas.height;
      ctx.fillStyle = '#000'; ctx.fillRect(0, 0, W, H);
      const y0 = H / 2;
      ctx.strokeStyle = axisColor; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(0, y0); ctx.lineTo(W, y0); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, H); ctx.stroke();
      ctx.fillStyle = axisColor; ctx.font = '14px sans-serif'; ctx.fillText(label, 10, 15);

      ctx.strokeStyle = waveColor; ctx.lineWidth = 2;
      ctx.beginPath();
      const scaleY = (H / 2) / yMax;
      const ptsPerSym = samplesPerSymbol;
      let x = 0, y = y0 - data[0] * scaleY;
      ctx.moveTo(x, y);
      for (let i = 1; i < data.length; i++) {
        if (i % ptsPerSym === 0) { ctx.stroke(); ctx.beginPath(); }
        x = (i / data.length) * W; y = y0 - data[i] * scaleY;
        ctx.lineTo(x, y);
      }
      ctx.stroke();
    }

    function drawStepWave(ctx, values, yMax, label) {
      const W = ctx.canvas.width, H = ctx.canvas.height;
      ctx.fillStyle = '#000'; ctx.fillRect(0, 0, W, H);
      const y0 = H / 2;
      ctx.strokeStyle = axisColor; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(0, y0); ctx.lineTo(W, y0); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, H); ctx.stroke();
      ctx.fillStyle = axisColor; ctx.font = '14px sans-serif'; ctx.fillText(label, 10, 15);

      ctx.strokeStyle = waveColor; ctx.lineWidth = 2;
      ctx.beginPath();
      const scaleY = (H / 2) / yMax;
      ctx.moveTo(0, y0 - values[0] * scaleY);
      for (let sym = 0; sym < values.length; sym++) {
        const xEnd = ((sym + 1) / values.length) * W;
        const yVal = y0 - values[sym] * scaleY;
        ctx.lineTo(xEnd, yVal);
        if (sym < values.length - 1) {
          const yNext = y0 - values[sym+1] * scaleY;
          ctx.lineTo(xEnd, yNext);
        }
      }
      ctx.stroke();
    }

    function drawHorizontalThresholds(ctx, levels, yMax) {
      if (!levels || !levels.length) return;
      const W = ctx.canvas.width, H = ctx.canvas.height;
      const y0 = H / 2;
      const scaleY = (H / 2) / yMax;
      ctx.save();
      ctx.setLineDash([4, 6]);
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let i = 0; i < levels.length; i++) {
        const y = y0 - levels[i] * scaleY;
        // skip if clearly off-canvas to avoid extra joins
        if (y < -5 || y > H + 5) continue;
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
      }
      ctx.stroke();
      ctx.restore();
    }

    // Dynamic ranges based on symbol amplitudes
    let Imax = 1, Qmax = 1;
    for (let i = 0; i < N; i++) { Imax = Math.max(Imax, Math.abs(Ivals[i])); Qmax = Math.max(Qmax, Math.abs(Qvals[i])); }
    const yI = Imax * 1.2;
    const yQ = Qmax * 1.2;
    const yC = (Imax + Qmax) * 1.2 + 3 * ns;

    // Draw modulation waveforms
    drawWave(ctxIcos,     IcosSamples,     yI, 'I(t) * cos(2\u03C0f t)');
    drawWave(ctxQsin,     QsinSamples,     yQ, 'Q(t) * sin(2\u03C0f t)');
    drawWave(ctxCombined, combinedSamples, yC, 'Icos + Qsin + noise');
    
    // Mixed (for illustration)
    drawWave(ctxIcosMix,  IcosMixSamples,  yC, '(I+Q+noise) * cos(2\u03C0f t)');
    drawWave(ctxQsinMix,  QsinMixSamples,  yC, '(I+Q+noise) * sin(2\u03C0f t)');

    // Estimated baseband (fixed theoretical axis range with 100% headroom)
    const yMaxEst = Math.max(1, ((1 << kAxis) - 1) * scale * 2.0);
    drawStepWave(ctxIext, Iest, yMaxEst, 'Estimated I(t)');
    // Decision thresholds for current constellation (interior only)
    const thresholds = [];
    const Lthr = 1 << kAxis; // √M levels per axis
    for (let b = -(Lthr - 2); b <= (Lthr - 2); b += 2) { thresholds.push(b * scale); }
    drawHorizontalThresholds(ctxIext, thresholds, yMaxEst);

    drawStepWave(ctxQext, Qest, yMaxEst, 'Estimated Q(t)');
    drawHorizontalThresholds(ctxQext, thresholds, yMaxEst);

    // Constellation
    const Wc = ctxConst.canvas.width, Hc = ctxConst.canvas.height;
    ctxConst.fillStyle = '#000'; ctxConst.fillRect(0, 0, Wc, Hc);
    ctxConst.strokeStyle = axisColor; ctxConst.lineWidth = 1;
    ctxConst.beginPath(); ctxConst.moveTo(0, Hc/2); ctxConst.lineTo(Wc, Hc/2);
    ctxConst.moveTo(Wc/2, 0); ctxConst.lineTo(Wc/2, Hc); ctxConst.stroke();
    ctxConst.fillStyle = axisColor; ctxConst.font = '16px sans-serif';
    ctxConst.fillText('I', Wc - 15, Hc/2 - 5); ctxConst.fillText('Q', Wc/2 + 5, 15);
    ctxConst.font = '14px sans-serif'; ctxConst.fillText('Measured Constellation (Î,Q̂)', 10, 20);

    // Static scaling per current QAM order (display normalized so decision box fills view)
    const margin = 25;
    const Laxis = 1 << kAxis;              // levels per axis (√M)
    const maxAbs = Math.max(1, Laxis - 1); // max |symbol amplitude| (odd levels)
    const visAbs = Math.max(1, Laxis);     // outer decision boundary at ±√M (before normalization)
    const maxRadiusPx = Math.min(Wc, Hc) / 2 - margin;
    // Include normalization so the bounding square (±√M·scale) fills the plot
    const unitToPx = maxRadiusPx / (visAbs * scale);

    // Grid: draw symbol-level lines (odd levels) and decision boundaries (midpoints)
    ctxConst.save();
    // Symbol levels (odd integers: ..., -3, -1, +1, +3, ...)
    ctxConst.strokeStyle = '#666';
    ctxConst.lineWidth = 1;
    ctxConst.setLineDash([3, 6]);
    ctxConst.beginPath();
    for (let lvl = -maxAbs; lvl <= maxAbs; lvl += 2) {
      const x = Wc/2 + (lvl * scale) * unitToPx;   // vertical grid at I = lvl·scale
      const y = Hc/2 - (lvl * scale) * unitToPx;   // horizontal grid at Q = lvl·scale
      ctxConst.moveTo(x, 0); ctxConst.lineTo(x, Hc);
      ctxConst.moveTo(0, y); ctxConst.lineTo(Wc, y);
    }
    ctxConst.stroke();
    // Decision boundaries (even integers incl. outermost ±√M)
    ctxConst.setLineDash([]);
    ctxConst.strokeStyle = '#aaa';
    ctxConst.lineWidth = 1.5;
    ctxConst.beginPath();
    for (let b = -visAbs; b <= visAbs; b += 2) {
      const xB = Wc/2 + (b * scale) * unitToPx;
      const yB = Hc/2 - (b * scale) * unitToPx;
      ctxConst.moveTo(xB, 0); ctxConst.lineTo(xB, Hc);
      ctxConst.moveTo(0, yB); ctxConst.lineTo(Wc, yB);
    }
    ctxConst.stroke();
    // Bounding square around the outer decision region (±√M)
    const left = Wc/2 - (visAbs * scale) * unitToPx;
    const right = Wc/2 + (visAbs * scale) * unitToPx;
    const top = Hc/2 - (visAbs * scale) * unitToPx;
    const bottom = Hc/2 + (visAbs * scale) * unitToPx;
    ctxConst.strokeStyle = '#ddd';
    ctxConst.lineWidth = 2;
    ctxConst.strokeRect(left, top, right - left, bottom - top);
    ctxConst.restore();

    const r = 5;
    const clipAmp = Math.max(0, visAbs * scale - r / unitToPx); // keep full dot inside bounds
    for (let sym = 0; sym < N; sym++) {
      const bits = symBitsArr[sym];
      const Ii = Math.max(-clipAmp, Math.min(clipAmp, Iest[sym]));
      const Qi = Math.max(-clipAmp, Math.min(clipAmp, Qest[sym]));
      const x = Wc/2 + Ii * unitToPx;
      const y = Hc/2 - Qi * unitToPx;
      ctxConst.fillStyle = colorForBits(bits);
      ctxConst.beginPath(); ctxConst.arc(x, y, r, 0, 2*Math.PI); ctxConst.fill();
      ctxConst.fillStyle = axisColor;
      const dx = (Ii >= 0 ? 10 : -20), dy = (Qi >= 0 ? -10 : 20);
      ctxConst.fillText(bits, x + dx, y + dy);
    }
  }

  updateSimulation();
  input.addEventListener('input', updateSimulation);
  freqInput.addEventListener('input', updateSimulation);
  noiseInput.addEventListener('input', updateSimulation);
  modOrderSelect.addEventListener('change', updateSimulation);
  normCheckbox.addEventListener('change', updateSimulation);
})();
</script>
</body>
</html>
